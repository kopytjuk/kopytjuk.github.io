<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Wrap C&#43;&#43; algorithms in Python for pre-production evaluation and experimentation. | Marat&#39;s blog</title>
<meta name="keywords" content="" />
<meta name="description" content="TLDR; In model based design paradigm one often implements a proof-of-concept solution in a scripting language before porting the logic to a more performant low-level language like C/C&#43;&#43;. This article describes the benefits of calling production-ready (C/C&#43;&#43;) ports in Python for functional evaluation and analysis. Assessment tools developed previously during the experimentation stage can be reused. Furthermore, the complexity for experimentation with various internal parameters is reduced, which can optimize costs and expensive debugging prior to the final deployment.">
<meta name="author" content="">
<link rel="canonical" href="https://kopytjuk.github.io/posts/wrapping-cpp-algorithms/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://kopytjuk.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://kopytjuk.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kopytjuk.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://kopytjuk.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://kopytjuk.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Wrap C&#43;&#43; algorithms in Python for pre-production evaluation and experimentation." />
<meta property="og:description" content="TLDR; In model based design paradigm one often implements a proof-of-concept solution in a scripting language before porting the logic to a more performant low-level language like C/C&#43;&#43;. This article describes the benefits of calling production-ready (C/C&#43;&#43;) ports in Python for functional evaluation and analysis. Assessment tools developed previously during the experimentation stage can be reused. Furthermore, the complexity for experimentation with various internal parameters is reduced, which can optimize costs and expensive debugging prior to the final deployment." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kopytjuk.github.io/posts/wrapping-cpp-algorithms/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-05T11:19:40&#43;01:00" />
<meta property="article:modified_time" content="2022-03-05T11:19:40&#43;01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Wrap C&#43;&#43; algorithms in Python for pre-production evaluation and experimentation."/>
<meta name="twitter:description" content="TLDR; In model based design paradigm one often implements a proof-of-concept solution in a scripting language before porting the logic to a more performant low-level language like C/C&#43;&#43;. This article describes the benefits of calling production-ready (C/C&#43;&#43;) ports in Python for functional evaluation and analysis. Assessment tools developed previously during the experimentation stage can be reused. Furthermore, the complexity for experimentation with various internal parameters is reduced, which can optimize costs and expensive debugging prior to the final deployment."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://kopytjuk.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Wrap C++ algorithms in Python for pre-production evaluation and experimentation.",
      "item": "https://kopytjuk.github.io/posts/wrapping-cpp-algorithms/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Wrap C++ algorithms in Python for pre-production evaluation and experimentation.",
  "name": "Wrap C\u002b\u002b algorithms in Python for pre-production evaluation and experimentation.",
  "description": "TLDR; In model based design paradigm one often implements a proof-of-concept solution in a scripting language before porting the logic to a more performant low-level language like C/C++. This article describes the benefits of calling production-ready (C/C++) ports in Python for functional evaluation and analysis. Assessment tools developed previously during the experimentation stage can be reused. Furthermore, the complexity for experimentation with various internal parameters is reduced, which can optimize costs and expensive debugging prior to the final deployment.",
  "keywords": [
    
  ],
  "articleBody": "TLDR; In model based design paradigm one often implements a proof-of-concept solution in a scripting language before porting the logic to a more performant low-level language like C/C++. This article describes the benefits of calling production-ready (C/C++) ports in Python for functional evaluation and analysis. Assessment tools developed previously during the experimentation stage can be reused. Furthermore, the complexity for experimentation with various internal parameters is reduced, which can optimize costs and expensive debugging prior to the final deployment. In the end of the article the key benefits and limitations are presented.\nMotivation Often, algorithms implemented in the automotive or other industrial domains are developed using the model-based design (MbD) idiom [1]. Roughly the workflow involves:\n Definition of computation steps in a high level (or even visual) language. E.g. val = read_sensor() or res = compute_mean(val) etc. Simulation and experimentation (with virtual/artificial data or system behaviour). Creating visualizations or performance assessments of the algorithm. Code generation (porting) for the target environment (e.g. C for embedded devices or C++ for a specialized server hardware). Finally, testing of the generated code on the target environment  Thus approach allows fast (rapid) prototyping and high quality code, since the generators are often well tested.\nCompanies like Mathworks provide specialized tools across the whole development chain. Often those tools are expensive for small projects so a smaller solution may be suitable.\nHowever, for small projects (with a smaller budget) the developers may create a Proof of Concept (PoC) for the algorithm in a scripting language of their choice (like Python or Scala) before turning to C/C++ ports. In addition to that, the engineers usually want to calculate some quality metrics like mean squared error (MSE) or accuracy (for classification tasks) to show (off) how well the logic is performing.\nThe “architecture” on the development machine would look similar to the following diagram:\nThe functional blocks may be code blocks of a single Python script or alternatively, a collection of scripts passing data files between them.\nAfter the stakeholders are satisfied, the developers may refactor the codebase for production use. Note that keeping the same language as in PoC stage is only possible if the algorithm is intended to run on the same type of machines as the developers use. More often, the target platform (e.g. an embedded device like a vacuum cleaner robot) requires a device specific implementation – the engineers are forced to rewrite the logic in a lower-level lanauge. Even if the target platform is a “normal” PC, the engineers want to do the reimplementation for execution speed and scale.\nBut how to make sure that the final implementation is functionally as good as the PoC? Please note, that a functional evaluation involves a pure evaluation focusing on the algorithmic part first, often ignoring communication issues and other intergration effects.\nA naive assessment approach would involve compiling generated code, transmit the build to the target device, generate some (artificial) input data, run the executable and simultaniously record the algorithm’s outputs:\nEven if the developers use an emulator for the target device or simply compile a regular executable on their develepoment machine, they always have to introduce some overhead “measuring” the algorithm’s internals and its outputs. Of course, in return for the additional complexity the engineers will be able to evaluate the real world performance including communication delays and performance fall-offs. Also they will be more sure that system libraries on the target device are working as intended. Still, the measurement brings additional efforts to the workbench and slows down the development.\nLet’s summarize the key benefits and downsides of the approach above:\n   Advantages Drawbacks     Execution on the target device Data feed to the target device has to be implemented   Impact of execution speed, data transmission and network errors can be evaluated Recording data introduces more complexity (and/or special debugging hardware)    Proposed solution For the functional assessment following architecture is proposed. The low-level language (C++) port is wrapped into a shared library and called from the high level language (e.g. Python). The (discrete) wall time is simulated in a for loop the outputs are recorded to a container (like list()) or saved to disk. Finally the outputs of the algorithm are evaluated in the same manner as in the PoC stage.\nAddionally to addressing the drawbacks from the last section the following can be achieved following easily:\n change the internal parameters within the loop apply (time-varying) noise to input data observe and record internal state variables like buffers or counters reset/manipulate the internal state  In the next section provides a basic code overview required for the proposed approach.\nSoftware architecture C++ First, an implementation in the low-level language is needed. Most probably, the required methods like (getters and setters), step() or run() are already implemented, so the proposed changes to match the code sceleton below are expected to be small.\n// customalgo.hpp  #include  class CustomAlgo {  public:  CustomAlgo(float param);   // the algorithm main routine for a single timestep  float step(float input);   void set_param(float p);  void reset();   // interface to the internals  std::vectorfloat get_state();   // attributes and methods ...  private:  float _param;  std::vectorfloat _state; }; Python interface (pybind11) The following module defines a Python wrapper for the C++ object above. Take a look at the official pybind11 documentation.\n#include #include \"customalgo.hpp\" namespace py = pybind11;  PYBIND11_MODULE(customalgo, m) {  py::class_CustomAlgo(m, \"CustomAlgo\")  .def(py::initconst float \u0026()) // constructor  .def(\"step\", \u0026CustomAlgo::step)  .def(\"set_param\", \u0026CustomAlgo::set_param)  .def(\"get_state\", \u0026CustomAlgo::get_state); } After a successful compilation a .so (Unix) or .dll (Windows) shared library is available, which can be imported into any Python module.\nPython On the Python side the possibilities are endless. A developer may call step() methon in a loop and record the results. Alternatively one may instantiate the algorithm multiple times and run with same data and several parameters, parametrize it on the fly etc …\nimport random  # shared lib import customalgo  # your evaluation code (e.g. from PoC) from eval import evaluate  algo = customalgo.CustomAlgo(42.42)  # for storing outputs results = list()  # for storing internal states states = list()  # the loop simulates time for t in range(10):  inp = random.randn() # example input   # try out a parameter change within the loop  if t == 5:  algo.set_param(1234)   # collect internal states for detailed analysis  states.append(algo.get_state())   res = algo.step(inp) # run a single step  results.append(res)  # evaluate and analyse evaluate(results) detailed_analysis(states, results) Key Benefits Let’s summarize the key benefits of making the logic accessible in a high level language like Python:\n Avoid data feeding and recording efforts for the target environment or hardware. Manipulate or reset the internal state within the simulation loop in the scripting language. Evaluate your algorithm with various inputs and parameters without additional C++ code for data feeding and result conversion. Simulation, analysis and evaluation are directly in Python, libraries like scikit-learn for evaluation or mlflow for experiment tracking can be used effortlessly. Compare your PoC with the final implementation easily (even in the same for-loop)  Limitations Please note that the proposed approach has also some limitations which you have to be aware of, before starting intergrating the workflow in your project:\n Use it for functional assessment only. It is not a replacement for a full system test. Target device specific routines relying on embedded circuits, e.g. ASICs for audio processing or TPUs for neural network inference may be unavailable on your (unix-oid) development machine. Those have to be reimplemented/replaced in C/C++. Similar to the statement above, in case you have proprietary target device specific implementations of libraries you link to, first check if they are reliable and behave in the equal manner to those on your development machine.  You want more? If you are interested in the concepts and challenges of algorithm development I recommend following resources:\n An article of an audio processing engineer bridging the gap between Python and C++ code with pythran. The library is not very mature but the charming idea is to skip the C++ coding entirely. Take a look how Mathworks pitches model based design A ROS1 tutorial on how to feed a C++ node implementation from Python. Numba for JIT compiling of python routines, an interesting alternative for computing demanding application before porting everything to C++. prometeo an experimental Python-to-C transpiler and domain specific language for embedded high-performance computing. The output of the package is a (Python-) indenpendent C code.  Credits Thanks to @annaformaniuk and Christian for discussions and proof reading.\nReferences [1] https://en.wikipedia.org/wiki/Model-based_design\n[2] pybind11 — Seamless operability between C++11 and Python\n",
  "wordCount" : "1406",
  "inLanguage": "en",
  "datePublished": "2022-03-05T11:19:40+01:00",
  "dateModified": "2022-03-05T11:19:40+01:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kopytjuk.github.io/posts/wrapping-cpp-algorithms/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Marat's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kopytjuk.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kopytjuk.github.io/" accesskey="h" title="Marat&#39;s blog (Alt + H)">Marat&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Wrap C&#43;&#43; algorithms in Python for pre-production evaluation and experimentation.
    </h1>
    <div class="post-meta"><span title='2022-03-05 11:19:40 +0100 CET'>March 5, 2022</span>

</div>
  </header> 
  <div class="post-content"><!-- raw HTML omitted -->
<h2 id="tldr">TLDR;<a hidden class="anchor" aria-hidden="true" href="#tldr">#</a></h2>
<p>In <em>model based design</em> paradigm one often implements a proof-of-concept solution in a scripting language before porting the logic to a more performant low-level language like C/C++.
This article describes the benefits of calling production-ready (C/C++) ports in Python for <strong>functional</strong> evaluation and analysis. Assessment tools developed previously during the experimentation stage can be reused. Furthermore, the complexity for experimentation with various internal parameters is reduced, which can optimize costs and expensive debugging prior to the final deployment. In the end of the article the key benefits and limitations are presented.</p>
<h2 id="motivation">Motivation<a hidden class="anchor" aria-hidden="true" href="#motivation">#</a></h2>
<p>Often, algorithms implemented in the automotive or other industrial domains are developed using the <a href="https://en.wikipedia.org/wiki/Model-based_design">model-based design</a> (MbD) idiom [1]. Roughly the workflow involves:</p>
<ol>
<li>Definition of <em>computation steps in a high level</em> (or even visual) language. E.g. <code>val = read_sensor()</code> or <code>res = compute_mean(val)</code> etc.</li>
<li><em>Simulation and experimentation</em> (with virtual/artificial data or system behaviour). Creating visualizations or performance assessments of the algorithm.</li>
<li><em>Code generation</em> (porting) for the target environment (e.g. C for embedded devices or C++ for a specialized server hardware).</li>
<li>Finally, <em>testing</em> of the generated code on the target environment</li>
</ol>
<p>Thus approach allows fast (rapid) prototyping <strong>and</strong> high quality code, since the generators are often well tested.</p>
<p>Companies like <a href="https://de.mathworks.com/">Mathworks</a> provide specialized tools across the whole development chain. Often those tools are expensive for small projects so a smaller solution may be suitable.</p>
<p>However, for small projects (with a smaller budget) the developers may create a Proof of Concept (PoC) for the algorithm in a scripting language of their choice (like Python or Scala) before turning to C/C++ ports. In addition to that, the engineers usually want to calculate some quality metrics like mean squared error (MSE) or accuracy (for classification tasks) to show (off) how well the logic is performing.</p>
<p>The &ldquo;architecture&rdquo; on the development machine would look similar to the following diagram:</p>
<p><img loading="lazy" src="poc-arch.png" alt="poc-arch"  />
</p>
<p>The functional blocks may be code blocks of a single Python script or alternatively, a collection of scripts passing data files between them.</p>
<p>After the stakeholders are satisfied, the developers may refactor the codebase for production use. Note that keeping the same language as in PoC stage is only possible if the algorithm is intended to run on the same type of machines as the developers use. More often, the target platform (e.g. an embedded device like a vacuum cleaner robot) requires a device specific implementation &ndash; the engineers are forced to rewrite the logic in a lower-level lanauge. Even if the target platform is a &ldquo;normal&rdquo; PC,  the engineers want to do the reimplementation for execution speed and scale.</p>
<p>But how to make sure that the final implementation is functionally as good as the PoC? Please note, that a functional evaluation involves a pure evaluation focusing on the algorithmic part first, often ignoring communication issues and other intergration effects.</p>
<p>A naive assessment approach would involve compiling generated code, transmit the build to the target device, generate some (artificial) input data, run the executable and simultaniously record the algorithm&rsquo;s outputs:</p>
<p><img loading="lazy" src="target-arch.png" alt="target-arch"  />
</p>
<p>Even if the developers use an emulator for the target device or simply compile a regular executable on their develepoment machine, they always have to introduce some overhead &ldquo;measuring&rdquo; the algorithm&rsquo;s internals and its outputs. Of course, in return for the additional complexity the engineers will be able to evaluate the real world performance including communication delays and performance fall-offs. Also they will be more sure that system libraries on the target device are working as intended. Still, the measurement brings additional efforts to the workbench and slows down the development.</p>
<p>Let&rsquo;s summarize the key benefits and downsides of the approach above:</p>
<table>
<thead>
<tr>
<th>Advantages</th>
<th>Drawbacks</th>
</tr>
</thead>
<tbody>
<tr>
<td>Execution on the target device</td>
<td>Data feed to the target device has to be implemented</td>
</tr>
<tr>
<td>Impact of execution speed, data transmission and network errors can be evaluated</td>
<td>Recording data introduces more complexity (and/or special debugging hardware)</td>
</tr>
</tbody>
</table>
<h2 id="proposed-solution">Proposed solution<a hidden class="anchor" aria-hidden="true" href="#proposed-solution">#</a></h2>
<p>For the functional assessment following architecture is proposed. The low-level language (C++) port is wrapped into a shared library and called from the high level language (e.g. Python). The (discrete) wall time is simulated in a  <code>for</code> loop  the outputs are recorded to a container (like <code>list()</code>) or saved to disk. Finally the outputs of the algorithm are evaluated in the same manner as in the PoC stage.</p>
<p><img loading="lazy" src="proposed-arch.png" alt="proposed-arch"  />
</p>
<p>Addionally to addressing the drawbacks from the last section the following can be achieved following easily:</p>
<ul>
<li>change the internal parameters within the loop</li>
<li>apply (time-varying) noise to input data</li>
<li>observe and record internal state variables like buffers or counters</li>
<li>reset/manipulate the internal state</li>
</ul>
<p>In the next section provides a basic code overview required for the proposed approach.</p>
<h2 id="software-architecture">Software architecture<a hidden class="anchor" aria-hidden="true" href="#software-architecture">#</a></h2>
<h3 id="c">C++<a hidden class="anchor" aria-hidden="true" href="#c">#</a></h3>
<p>First, an implementation in the low-level language is needed. Most probably, the required methods like (getters and setters), <code>step()</code> or <code>run()</code> are already implemented, so the proposed changes to match the code sceleton below are expected to be small.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// customalgo.hpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomAlgo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        CustomAlgo(<span style="color:#66d9ef">float</span> param);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// the algorithm main routine for a single timestep
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">float</span> <span style="color:#a6e22e">step</span>(<span style="color:#66d9ef">float</span> input);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_param</span>(<span style="color:#66d9ef">float</span> p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reset</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// interface to the internals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> get_state();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// attributes and methods ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">float</span> _param;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> _state;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="python-interface-pybind11">Python interface (pybind11)<a hidden class="anchor" aria-hidden="true" href="#python-interface-pybind11">#</a></h3>
<p>The following module defines a Python wrapper for the <code>C++</code> object above. Take a look at the official <a href="https://pybind11.readthedocs.io/en/stable/index.html">pybind11</a> documentation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;pybind11/pybind11.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;customalgo.hpp&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> py <span style="color:#f92672">=</span> pybind11;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PYBIND11_MODULE(customalgo, m) {
</span></span><span style="display:flex;"><span>    py<span style="color:#f92672">::</span>class_<span style="color:#f92672">&lt;</span>CustomAlgo<span style="color:#f92672">&gt;</span>(m, <span style="color:#e6db74">&#34;CustomAlgo&#34;</span>)
</span></span><span style="display:flex;"><span>        .def(py<span style="color:#f92672">::</span>init<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;&gt;</span>())  <span style="color:#75715e">// constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        .def(<span style="color:#e6db74">&#34;step&#34;</span>, <span style="color:#f92672">&amp;</span>CustomAlgo<span style="color:#f92672">::</span>step)
</span></span><span style="display:flex;"><span>        .def(<span style="color:#e6db74">&#34;set_param&#34;</span>, <span style="color:#f92672">&amp;</span>CustomAlgo<span style="color:#f92672">::</span>set_param)
</span></span><span style="display:flex;"><span>        .def(<span style="color:#e6db74">&#34;get_state&#34;</span>, <span style="color:#f92672">&amp;</span>CustomAlgo<span style="color:#f92672">::</span>get_state);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After a successful compilation a <code>.so</code> (Unix) or <code>.dll</code> (Windows) shared library is available, which can be imported into any Python module.</p>
<h3 id="python">Python<a hidden class="anchor" aria-hidden="true" href="#python">#</a></h3>
<p>On the Python side the possibilities are endless. A developer may call <code>step()</code> methon in a loop and record the results. Alternatively one may instantiate the algorithm multiple times and run with same data and several parameters, parametrize it on the fly etc &hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> random
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># shared lib</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> customalgo
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># your evaluation code (e.g. from PoC)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> eval <span style="color:#f92672">import</span> evaluate
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>algo <span style="color:#f92672">=</span> customalgo<span style="color:#f92672">.</span>CustomAlgo(<span style="color:#ae81ff">42.42</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># for storing outputs</span>
</span></span><span style="display:flex;"><span>results <span style="color:#f92672">=</span> list()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># for storing internal states</span>
</span></span><span style="display:flex;"><span>states <span style="color:#f92672">=</span> list()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the loop simulates time</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>):
</span></span><span style="display:flex;"><span>    inp <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randn()  <span style="color:#75715e"># example input</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># try out a parameter change within the loop</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> t <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>:
</span></span><span style="display:flex;"><span>        algo<span style="color:#f92672">.</span>set_param(<span style="color:#ae81ff">1234</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># collect internal states for detailed analysis</span>
</span></span><span style="display:flex;"><span>    states<span style="color:#f92672">.</span>append(algo<span style="color:#f92672">.</span>get_state())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> algo<span style="color:#f92672">.</span>step(inp)  <span style="color:#75715e"># run a single step</span>
</span></span><span style="display:flex;"><span>    results<span style="color:#f92672">.</span>append(res)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># evaluate and analyse</span>
</span></span><span style="display:flex;"><span>evaluate(results)
</span></span><span style="display:flex;"><span>detailed_analysis(states, results)
</span></span></code></pre></div><h2 id="key-benefits">Key Benefits<a hidden class="anchor" aria-hidden="true" href="#key-benefits">#</a></h2>
<p>Let&rsquo;s summarize the key benefits of making the logic accessible in a high level language like Python:</p>
<ul>
<li>Avoid data feeding and recording efforts for the target environment or hardware. Manipulate or reset the internal state within the simulation loop in the scripting language.</li>
<li>Evaluate your algorithm with various inputs and parameters without additional C++ code for data feeding and result conversion.</li>
<li>Simulation, analysis and evaluation are directly in Python, libraries like <code>scikit-learn</code> for evaluation or <code>mlflow</code> for experiment tracking can be used effortlessly.</li>
<li>Compare your PoC with the final implementation easily (even in the same <code>for</code>-loop)</li>
</ul>
<h2 id="limitations">Limitations<a hidden class="anchor" aria-hidden="true" href="#limitations">#</a></h2>
<p>Please note that the proposed approach has also some limitations which you have to be aware of, before starting intergrating the workflow in your project:</p>
<ul>
<li><strong>Use it for functional assessment only</strong>. It is not a replacement for a full system test.</li>
<li>Target device specific routines relying on embedded circuits, e.g. ASICs for audio processing or TPUs for neural network inference may be unavailable on your (<code>unix</code>-oid) development machine. Those have to be reimplemented/replaced in C/C++.</li>
<li>Similar to the statement above, in case you have proprietary target device specific implementations of libraries you link to, first check if they are reliable and behave in the equal manner to those on your development machine.</li>
</ul>
<h2 id="you-want-more">You want more?<a hidden class="anchor" aria-hidden="true" href="#you-want-more">#</a></h2>
<p>If you are interested in the concepts and challenges of algorithm development I recommend following resources:</p>
<ul>
<li>An <a href="https://serge-sans-paille.github.io/pythran-stories/pythran-as-a-bridge-between-fast-prototyping-and-code-deployment.html">article</a> of an audio processing engineer bridging the gap between Python and C++ code with <code>pythran</code>. The library is not very mature but the charming idea is to skip the C++ coding entirely.</li>
<li>Take a look how <a href="https://de.mathworks.com/solutions/model-based-design.html">Mathworks pitches</a> model based design</li>
<li>A <a href="http://wiki.ros.org/ROS/Tutorials/Using%20a%20C%2B%2B%20class%20in%20Python">ROS1 tutorial</a> on how to feed a C++ node implementation from Python.</li>
<li><a href="http://numba.pydata.org/">Numba</a> for JIT compiling of python routines, an interesting alternative for computing demanding application before porting everything to C++.</li>
<li><a href="https://github.com/zanellia/prometeo">prometeo</a> an experimental Python-to-C transpiler and domain specific language for embedded high-performance computing. The output of the package is a (Python-) indenpendent C code.</li>
</ul>
<h2 id="credits">Credits<a hidden class="anchor" aria-hidden="true" href="#credits">#</a></h2>
<p>Thanks to <a href="https://github.com/annaformaniuk">@annaformaniuk</a> and <a href="https://www.linkedin.com/in/christian-herzog-367b21156/">Christian</a> for discussions and proof reading.</p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<p>[1] <a href="https://en.wikipedia.org/wiki/Model-based_design">https://en.wikipedia.org/wiki/Model-based_design</a></p>
<p>[2] <a href="https://pybind11.readthedocs.io/en/stable/index.html">pybind11 — Seamless operability between C++11 and Python</a></p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://kopytjuk.github.io/">Marat&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
